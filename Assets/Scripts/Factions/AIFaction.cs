//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using UnityEngine;

namespace AssemblyCSharp
{
		public class AIFaction : Faction
		{
			public static float POSITIONWEIGHT = 1f;
			public static float ATTACKWEIGHT = 100f;
			public static Tile playerStart;
				public AIFaction ()
				{
			color = Highlight.ENEMY;	
				}


			public override void initiate(){
				makeUnit(0,0);
				makeUnit(Map.HEIGHT-1,Map.HEIGHT -1);
				makeUnit (10,10);
				playerStart = Grid.map.map[Map.WIDTH/2,Map.WIDTH/2];
			Grid.map.makeAllFog();
			}

			public override void startTurn(){
			checkIntegrity();
				foreach (Unit unit in units){
					doBestOption(unit);
				}
			checkIntegrity();
			Grid.turnManager.nextTurn();
			}

			public override void endTurn(){
				restoreMove();
			}

			public void doBestOption(Unit unit){
				Tile bestMove = unit.tile;
				float bestValue = evaluate(unit.tile,unit);
				float currentValue;
				List<Tile> tiles = Grid.map.getUnitMove(unit);
				foreach (Tile tile in tiles){
					currentValue = evaluate(tile, unit);
					if (currentValue > bestValue && !tile.hasUnit()){
						bestMove = tile;
						bestValue = currentValue;
					}
				}
				//MonoBehaviour.print("now moving to: "+ bestMove.x + ", " + bestMove.y + ". Value was: " + bestValue);
				Grid.map.moveUnit(unit,bestMove.x,bestMove.y);
				doBestAction(unit);
			}

			public float evaluate(Tile tile,Unit unit){
			float value = 0f;
				value += positionValue(tile,unit);
				value += attackValue(tile,unit);
			return value;
			}
			//how close to the center is it.
			private float positionValue(Tile tile,Unit unit){
			float value = 0f;
			value += (float) (Map.HEIGHT + Map.WIDTH - Grid.map.gridDistance(tile.x,playerStart.x,tile.y,playerStart.y));//Grid.map.searchForTile(tile.x,tile.y,playerStart,0,unit.moveCosts);
			value *= POSITIONWEIGHT;
			return value;
			}

			private float attackValue(Tile tile, Unit unit){
			float value = 0f;
			List<Tile> tiles = Grid.map.getTilesInMovement(tile.x,tile.y,TileCosts.Flat,unit.maxRnge);
			foreach(Tile otherTile in tiles){
				if (otherTile.hasUnit() && !otherTile.unit.faction.Equals(this)) value = 1f*ATTACKWEIGHT; //this should be more detailed later.
			}
			return value;
			}
			//takes a tile as the start point and a unit and returns all the enemy units in that units range
			private List<Unit> getUnitsInRange(Tile tile, Unit unit){
			List<Unit> units = new List<Unit>();
			List<Tile> tiles = Grid.map.getTilesInMovement(tile.x,tile.y,TileCosts.Flat,unit.maxRnge);
			foreach(Tile otherTile in tiles){
				if (otherTile.hasUnit() && otherTile.unit.faction != this) units.Add(otherTile.unit); //this should be more detailed later.
			}
			return units;
			}

			private void doBestAction(Unit unit){
			List<Unit> units = getUnitsInRange(unit.tile,unit);
			Unit[] unitArray = units.ToArray();
			if (units.Count > 0) {
				Controller.battle(unit,unitArray[0]);
			}
			}
		}
}

