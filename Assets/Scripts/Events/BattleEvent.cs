//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.34209
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using System;
using System.Collections;
using System.Collections.Generic;
using AssemblyCSharp;
/* a battle does the following:
 * resolves initial effects (who goes first, what buffs are applied, etc...)
 * has the attacker swing at the attacked unit
 * resolves aftereffects (damage, skills, etc...)
 * if the attacked does not die, the attacked swings at the attacker
 * resolves aftereffects
 * resolves final effects (exp, skills and the like)
 */

namespace AssemblyCSharp
{
		public class BattleEvent
		{
		public Unit attacker,attacked;
		public Map map;
		public struct Attack{
			bool hit;
			string type;
			int damage;
		}
				public BattleEvent (Unit one, Unit two,Map m)
				{
			attacker = one;
			attacked = two;
			map = m;
				}

			public void battle(){
			initialEffects ();
			bool hit = swing(attacker,attacked);
			if (hit){
				resolveHit("attacker");
			}
			else resolveMiss("attacker");

			//check if the attacker died
			if (attacked.isDead()){ //I believe this works since the destroy command run in the unit does not take effect until the next frame, meaning the unit is not yet null.
				attacker.victory();	
				return;
			}
			//counter attack
			hit = swing(attacked,attacker);
			if (hit){
				resolveHit("attacked");
			}
			else resolveMiss("attacked");

			if (attacker.isDead()){
				attacked.victory();
				return;
			}

			}

			public void initialEffects(){
				List<Skill> skills = attacker.getSkills("attackerInitial");
				Skill.activateSkills(skills,"attackerInitial");
				skills = attacked.getSkills("attackedInitial");
				Skill.activateSkills(skills,"attackedInitial");
			}

			public bool swing(Unit one, Unit two){
			int hitChance = one.skl - two.dge;
			Random random = new Random();
			int hitFactor = random.Next (0,4); //0-4 (although it's inclusive so on rare occasions it could be 5).
			//print ("has a " + hitChance*20 + "% chance to hit");
			if (hitChance - hitFactor <= 0){
				//print ("missed");
				return false;
			}
			else return true;
			}

			public void resolveHit(string hitter){

			if (hitter.Equals("attacker")){
				List<Skill> skills = attacker.getSkills("attackerHit");
				Skill.activateSkills(skills,"attackerHit");
				skills = attacked.getSkills("defenderStruck");
				Skill.activateSkills(skills,"defenderStruck");

			    attacked.takeDamage(attacker.atk,"normal");//TODO make this work with different attack types
			}
			else{
				List<Skill> skills = attacked.getSkills("attackerHit");
				Skill.activateSkills(skills,"attackerHit");
				skills = attacker.getSkills("defenderStruck");
				Skill.activateSkills(skills,"defenderStruck");

				attacker.takeDamage(attacked.atk,"normal");
			}
			}

		public void resolveMiss(string hitter){
			if (hitter.Equals("attacker")){
				List<Skill> skills = attacker.getSkills("attackerMiss");
				Skill.activateSkills(skills,"attackerMiss");
				skills = attacked.getSkills("defenderDodged");
				Skill.activateSkills(skills,"defenderDodged");
			}
			else {
				List<Skill> skills = attacked.getSkills("attackerMiss");
				Skill.activateSkills(skills,"attackerMiss");
				skills = attacker.getSkills("defenderDodged");
				Skill.activateSkills(skills,"defenderDodged");
			}
		}
		}
}

